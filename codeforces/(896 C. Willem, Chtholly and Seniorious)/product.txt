<b>C. Willem, Chtholly and Seniorious</b>
time limit per test: 2 seconds
memory limit per test: 256 megabytes

— Willem...

— What's the matter?

— It seems that there's something wrong with Seniorious...

— I'll have a look...

<img stat>

Seniorious is made by linking special talismans in particular order.

After over 500 years, the carillon is now in bad condition, so Willem decides to examine it thoroughly.

Seniorious has \(n\) pieces of talisman. Willem puts them in a line, the \(i_{th}\) of which is an integer \(a_i\).

In order to maintain it, Willem needs to perform \(m\) operations.

There are four types of operations:

- 1 \(l\) \(r\) \(x\): For each \(i\) such that \(l ≤ i ≤ r\), assign \(a_i + x\) to \(a_i\).

- 2 \(l\) \(r\) \(x\): For each i such that \(l ≤ i ≤ r\), assign \(x\) to \(a_i\).

- 3 \(l\) \(r\) \(x\): Print the \(x_{th}\) smallest number in the index range \([l, r]\), i.e. the element at the \(x_{th}\) position if all the elements \(a_i\) such that \(l ≤ i ≤ r\) are taken and sorted into an array of non-decreasing integers. It's guaranteed that \(1 ≤ x ≤ r - l + 1\).

- 4 \(l\) \(r\) \(x\) \(y\): Print the sum of the \(x_{th}\) power of \(a_i\) such that \(l ≤ i ≤ r\), modulo y, i.e. .
(\({\sum_{i = l}^r {a_i}^x}\)) mod \(y\).


<b> Input </b>
The only line contains four integers \(n\), \(m\), \(seed\), \(v_{max}\) \((1 ≤ n, m ≤ 10^5, 0 ≤ seed < 10^9 + 7, 1 ≤ vmax ≤ 10^9)\).

The initial values and operations are generated using following pseudo code:


def rnd():

ret = seed
seed = (seed * 7 + 13) mod 1000000007
return ret

for i = 1 to n:

a[i] = (rnd() mod vmax) + 1

for i = 1 to m:

op = (rnd() mod 4) + 1
l = (rnd() mod n) + 1
r = (rnd() mod n) + 1

if (l > r):
swap(l, r)

if (op == 3):
x = (rnd() mod (r - l + 1)) + 1
else:
x = (rnd() mod vmax) + 1

if (op == 4):
y = (rnd() mod vmax) + 1


Here \(op\) is the type of the operation mentioned in the legend.

<b>Output</b>
For each operation of types \(3\) or \(4\), output a line containing the answer.


<b>Note</b>
In the first example, the initial array is {\(8, 9, 7, 2, 3, 1, 5, 6, 4, 8\)}.

The operations are:

- 2 6 7 9
- 1 3 10 8
- 4 4 6 2 4
- 1 4 5 8
- 2 1 7 1
- 4 7 9 4 4
- 1 2 7 9
- 4 5 8 1 1
- 2 5 7 5
- 4 3 10 8 5





The naive solution is to process each type of queries by iterating over the elements in the given range and applying the operation (type 1 or 2) or calculating the output (type 3 or 4).

This solution is extremely weak, as it is too slow to fit within the constraints of the problem.

To introduce a better solution, we may notice the special way of input, which is completely randomized for each single value.

Then, we can trick the probabilities of that randomization, to do this, we will divide our array into segments of consecutive equal elements; as it will be faster to jump over these segments rather than elements.

Assume \(S\) to be the number of segments in range \(l\) to \(r\). To process any type of queries in that range, we only need to jump over \(S\) segments.

The proof for that jumping over \(S\) segments is better than jumping over each single element in range; that is the \((S \le r-l+1)\), where \(r - l +1\) is the number of elements in range.

Let us define a merge operation, which is that operation performed after type 1 or 2 queries to merge consecutive elements in one segment after changing their values.

Now, we need to prove that \(S\) is small for the most cases.

After \(k\) merging operations, let's find the probability that index \(i\) is the right end of an interval. Note that the number of right ends is the same as the number of intervals.

This happens if and only if all of the \(k\) merges either don't contain \(i\) or have \(i\) as the right end. There are \(i + \left( \begin{array}{c} i-1 \\ 2 \end{array} \right) + \left( \begin{array}{c} n-i \\ 2 \end{array} \right) \) out of \(\left( \begin{array}{c} n \\ 2 \end{array} \right) \) possible merges which satisfy this. So the probability for \(k = 1\) is

\(1 - 2\left( \frac{i(n-i-1)}{n(n-1)} \right)\) \(\approx\) \( \left( \frac{i}{n} \right)^2 + (1 - \left( \frac{i}{n} \right))^2\)

And if we assume independence, it is
\(\left( \left( \frac{i}{n} \right)^2 + (1 - \left( \frac{i}{n} \right))^2\right)^k \)
after \(k\) random merges.

By linearity of expectation, the expected number of intervals (right ends) is

\({\sum_{i = 1}^n {\left( \left( \frac{i}{n} \right)^2 + (1 - \left( \frac{i}{n} \right))^2\right)^k }}\) \(\approx\) \(\int_0^1 {(x^2 + (1 - x)^2)^k dx}\).

After calculating this integration, it gives us \(E(S) = (n/k)\); as the merges increase, the number of segments decreases.

Now, we need to find a good data structure that can handle merges. We can use `std::map` to handle it.




Since the input in this problem is special, it depends on the random values generated by the coder, not those provided by the judge. Below is the code that handles this input.





Now, we need to use our data structure \(std::map\) to handle merges.

As I mentioned, in my approach, we need to split the array into consecutive segments with equal values, so instead of carrying a pair for each segment, we will store the value of the segment in its left border, and just ignore the other indexes within the same segment. As it will be easy to just jump from the current index to the leftmost element in the next segment in \(O(1)\).

That gives us an idea of how to use the map, we make a map whose key is the index, and the value is the value of the current segment.

For now, just put the inputs in the map.





#include<bits/stdc++.h>

const int mod;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
    std::map<int,long long>f;
    
	for (int i = 0; i < n; i++){
		a[i] = rnd() % vmax + 1;
        f[i] = a[i];
    }
    
    f[n] = -1;
    
	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);
		
		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;

		if (op == 1) {
			// do some logic
		}
		else if (op == 2) {
			//do some logic
		}
		else if (op == 3) {
			//do some logic
		}
		else if (op == 4) {
            y = rnd()%vmax+1;
			//do some logic
		}
	}
}




We have four types of queries, and for each of them, we need to handle the situation where the indexes l, r of the query are present in the map.

Thus, we can implement a function that finds the segment in which our index exists, and then split the segment by moving the value of the left border to it (assuming the index is not the left border).




#include<bits/stdc++.h>

const int mod;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

void divide(std::map<int, long long>& mp, int idx) {
	auto it = std::prev(mp.upper_bound(idx));

	if (it->first != idx)// the index was not the left border
		// set it as a border
		mp[idx] = it->second;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
    std::map<int,long long>f;
    
	for (int i = 0; i < n; i++){
		a[i] = rnd() % vmax + 1;
        f[i] = a[i];
    }
    
    f[n] = -1;
    
	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);
		
		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;
        
        divide(f,l);
        divide(f,r);
        
		if (op == 1) {
			// do some logic
		}
		else if (op == 2) {
			//do some logic
		}
		else if (op == 3) {
			//do some logic
		}
		else if (op == 4) {
            int y = rnd()%vmax+1;
			//do some logic
		}
	}
}




Now, let us dive into the queries.

For the first type of query, it will add some value \(x\) to all elements in the range \((l, r)\). This means in our structure, we need to add \(x\) to each left border in our `std::map`.

For the second type of query, it assigns the value \(x\) to each element in the range \((l, r)\). This means that all the old values stored in the range must be deleted, in other words, we must erase each left border present in the map in the given range. After that, we add one left border representing the new value \(x\).




#include<bits/stdc++.h>

const int mod;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

void divide(std::map<int, long long>& mp, int idx) {
	auto it = std::prev(mp.upper_bound(idx));

	if (it->first != idx)// the index was not the left border
		// set it as a border
		mp[idx] = it->second;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
	std::map<int, long long>f;

	for (int i = 0; i < n; i++) {
		a[i] = rnd() % vmax + 1;
		f[i] = a[i];
	}

	f[n] = -1;

	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);

		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;
        
        divide(f,l);
        divide(f,r);
		if (op == 1) {
			// iterate over all left borders in range, and increase them by x
			for (auto it = f.find(l); it->first != r; it++) {
				it->second += x;
			}

		}
		else if (op == 2) {
			//erase all left borders presented in the range, and then add new left border with new value x
			for (auto it = f.find(l); it->first != r; it = f.erase(it))
				;
			f[l] = x;
		}
		else if (op == 3) {
			//do some logic
		}
		else if (op == 4) {
			int y = rnd() % vmax + 1;
			//do some logic
		}
	}
}




#include<bits/stdc++.h>

const int mod;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

void divide(std::map<int, long long>& mp, int idx) {
	auto it = std::prev(mp.upper_bound(idx));

	if (it->first != idx)// the index was not the left border
		// set it as a border
		mp[idx] = it->second;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
	std::map<int, long long>f;

	for (int i = 0; i < n; i++) {
		a[i] = rnd() % vmax + 1;
		f[i] = a[i];
	}

	f[n] = -1;

	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);

		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;
        
        divide(f,l);
        divide(f,r);
		if (op == 1) {
			// iterate over all left borders in range, and increase them by x
			for (auto it = f.find(l); it->first != r; it++) {
				it->second += x;
			}

		}
		else if (op == 2) {
			//erase all left borders presented in the range, and then add new left border with new value x
			for (auto it = f.find(l); it->first != r; it = f.erase(it))
				;
			f[l] = x;
		}
		else if (op == 3) {
			//do some logic
		}
		else if (op == 4) {
			int y = rnd() % vmax + 1;
			//do some logic
		}
	}
}




That leaves us with the last two queries.

For the third query type, we are asked to print the \(x_{th}\) smallest number in the range \((l, r)\).

We only have indexes (left borders) that represent the value of their segments. We can count the frequency for each value in the given range, which helps to avoid iterating over elements one by one; we just calculate for each left border the size of the segment it exists within.

Now, assume we have a way to sort the values and keep their frequency. We can, for each value, subtract its frequency from the \(x\), and whenever it exceeds the \(x\), then the answer is the current value.

To calculate the frequency, you can just subtract the current left border from the next one; as it gives you the length of the segment, which is the frequency of the value represented in that segment.





#include<bits/stdc++.h>

const int mod;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

void divide(std::map<int, long long>& mp, int idx) {
	auto it = std::prev(mp.upper_bound(idx));

	if (it->first != idx)// the index was not the left border
		// set it as a border
		mp[idx] = it->second;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
	std::map<int, long long>f;

	for (int i = 0; i < n; i++) {
		a[i] = rnd() % vmax + 1;
		f[i] = a[i];
	}

	f[n] = -1;

	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);

		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;

		divide(f, l);
		divide(f, r);
		if (op == 1) {
			// iterate over all left borders in range, and increase them by x
			for (auto it = f.find(l); it->first != r; it++) {
				it->second += x;
			}

		}
		else if (op == 2) {
			//erase all left borders presented in the range, and then add new left border with new value x
			for (auto it = f.find(l); it->first != r; it = f.erase(it))
				;
			f[l] = x;
		}
		else if (op == 3) {
			std::vector<std::pair<long long, long long>> v; // to store the value with its frequency
			for (auto it = f.find(l); it->first != r; it++) {
				int frequency = std::next(it)->first - it->first;
				v.push_back({ it->second, frequency});
			}

			std::sort(v.begin(), v.end()); 
			for (auto [a, b] : v) {
				if (x < b) { // here, we passed the x smallest value.
					std::cout << a << "\n";
					break;
				}
				x -= b;
			}
		}
		else if (op == 4) {
			int y = rnd() % vmax + 1;
			//do some logic
		}
	}
}




For the fourth query type, we are asked to calculate:
(\({\sum_{i = l}^r {a_i}^x}\)) mod \(y\).

To solve it, we can apply similar logic to the third query. The number of distinct values in the range is small, so we can iterate over them (we proved it above). We can then, for each distinct value in the range \(z\), calculate its frequency \(f\). The answer will be the following summation:

(\({\sum_{z_0}^{z_k} f*({z_i}^x})\)) mod \(y\).

We calculate the frequency in the same way as in the third query.

As the exponential may be a very large number, we must find a way to implement the exponential efficiently. We can use binary exponentiation, which is a known technique that applies the concept of divide and conquer to find the powers in \(log(x)\) iterations.




#include<bits/stdc++.h>

const int mod;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

void divide(std::map<int, long long>& mp, int idx) {
	auto it = std::prev(mp.upper_bound(idx));

	if (it->first != idx)// the index was not the left border
		// set it as a border
		mp[idx] = it->second;
}

int binaryExp(int a, int b, int p) {
	int res = 1 % p;
	for (; b; b /= 2, a = 1LL * a * a % p) {
		if (b % 2) {
			res = 1LL * res * a % p;
		}
	}
	return res;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
	std::map<int, long long>f;

	for (int i = 0; i < n; i++) {
		a[i] = rnd() % vmax + 1;
		f[i] = a[i];
	}

	f[n] = -1;

	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);
		l--;
		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;

		divide(f, l);
		divide(f, r);
		if (op == 1) {
			// iterate over all left borders in range, and increase them by x
			for (auto it = f.find(l); it->first != r; it++) {
				it->second += x;
			}

		}
		else if (op == 2) {
			//erase all left borders presented in the range, and then add new left border with new value x
			for (auto it = f.find(l); it->first != r; it = f.erase(it))
				;
			f[l] = x;
		}
		else if (op == 3) {
			std::vector<std::pair<long long, long long>> v; // to store the value with its frequency
			for (auto it = f.find(l); it->first != r; it++) {
				int frequency = std::next(it)->first - it->first;
				v.push_back({ it->second, frequency});
			}

			std::sort(v.begin(), v.end()); 
			for (auto [a, b] : v) {
				if (x < b) { // here, we passed the x smallest value.
					std::cout << a << "\n";
					break;
				}
				x -= b;
			}
		}
		else if (op == 4) {
			int y = rnd() % vmax + 1;
			int ans = 0;
			for (auto it = f.find(l); it->first != r; it++) {
				int fr = (std::next(it)->first - it->first);
				ans = (ans + 1LL * fr * binaryExp(it->second % y, x, y)) % y;
			}
			std::cout << ans << "\n";
		}
	}
}




We forgot to initialize the mod with its value given in the statement. Let us fix it.





#include<bits/stdc++.h>

const int mod = 1e9+7;
int n, m, seed, vmax;

auto rnd() {
	int ret = seed;
	seed = (seed * 7LL + 13) % mod;
	return ret;
}

void divide(std::map<int, long long>& mp, int idx) {
	auto it = std::prev(mp.upper_bound(idx));

	if (it->first != idx)// the index was not the left border
		// set it as a border
		mp[idx] = it->second;
}

int binaryExp(int a, int b, int p) {
	int res = 1 % p;
	for (; b; b /= 2, a = 1LL * a * a % p) {
		if (b % 2) {
			res = 1LL * res * a % p;
		}
	}
	return res;
}

signed main() {

	std::cin >> n >> m >> seed >> vmax;

	std::vector<int>a(n);
	std::map<int, long long>f;

	for (int i = 0; i < n; i++) {
		a[i] = rnd() % vmax + 1;
		f[i] = a[i];
	}

	f[n] = -1;

	while (m--) {
		int op = 1 + (rnd() % 4);
		int l = 1 + (rnd() % n);
		int r = 1 + (rnd() % n);

		if (l > r)std::swap(l, r);
		l--;
		int x;
		if (op == 3)
			x = rnd() % (r - l);
		else
			x = rnd() % vmax + 1;

		divide(f, l);
		divide(f, r);
		if (op == 1) {
			// iterate over all left borders in range, and increase them by x
			for (auto it = f.find(l); it->first != r; it++) {
				it->second += x;
			}

		}
		else if (op == 2) {
			//erase all left borders presented in the range, and then add new left border with new value x
			for (auto it = f.find(l); it->first != r; it = f.erase(it))
				;
			f[l] = x;
		}
		else if (op == 3) {
			std::vector<std::pair<long long, long long>> v; // to store the value with its frequency
			for (auto it = f.find(l); it->first != r; it++) {
				int frequency = std::next(it)->first - it->first;
				v.push_back({ it->second, frequency});
			}

			std::sort(v.begin(), v.end()); 
			for (auto [a, b] : v) {
				if (x < b) { // here, we passed the x smallest value.
					std::cout << a << "\n";
					break;
				}
				x -= b;
			}
		}
		else if (op == 4) {
			int y = rnd() % vmax + 1;
			int ans = 0;
			for (auto it = f.find(l); it->first != r; it++) {
				int fr = (std::next(it)->first - it->first);
				ans = (ans + 1LL * fr * binaryExp(it->second % y, x, y)) % y;
			}
			std::cout << ans << "\n";
		}
	}
}




It seems the code works well in the sample.

Now, we can test if the solution gives overflow when calculating large numbers in the fourth query.

We may test the following:

<b>test1:</b> that may lead to large numbers.
- 1000 20 100000003 1000000000.

<b>test2:</b> that tests the borders of the constraints.
- 100000 1 1000000007 1000000000.





1000 20 100000003 1000000000





100000 1 1000000007 1000000000
